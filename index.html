<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>NebulaTouch v3: Ultimate Gesture OS</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap');
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body { 
            margin: 0; 
            overflow: hidden; 
            background: radial-gradient(ellipse at center, #0a0a1a 0%, #050505 100%);
            font-family: 'Orbitron', 'Courier New', monospace;
        }
        
        canvas { display: block; }
        
        #video-input { 
            position: absolute; 
            top: 0; 
            left: 0; 
            opacity: 0; 
            pointer-events: none; 
        }
        
        #ui {
            position: absolute;
            top: 20px; 
            left: 20px;
            color: #00ffcc;
            pointer-events: none;
            z-index: 10;
            background: linear-gradient(135deg, rgba(0, 20, 30, 0.9) 0%, rgba(0, 10, 20, 0.85) 100%);
            padding: 20px;
            border-radius: 16px;
            border: 2px solid transparent;
            background-clip: padding-box;
            box-shadow: 
                0 8px 32px rgba(0, 255, 204, 0.2),
                inset 0 1px 0 rgba(255, 255, 255, 0.1),
                0 0 0 2px rgba(0, 255, 204, 0.3);
            backdrop-filter: blur(20px) saturate(180%);
            max-height: 90vh;
            overflow-y: auto;
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            animation: slideInLeft 0.6s cubic-bezier(0.4, 0, 0.2, 1);
        }
        
        #ui::-webkit-scrollbar {
            width: 8px;
        }
        
        #ui::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
        }
        
        #ui::-webkit-scrollbar-thumb {
            background: linear-gradient(180deg, #00ffcc, #00ccaa);
            border-radius: 10px;
        }
        
        @keyframes slideInLeft {
            from {
                opacity: 0;
                transform: translateX(-50px);
            }
            to {
                opacity: 1;
                transform: translateX(0);
            }
        }
        
        h1 { 
            margin: 0 0 15px 0; 
            font-size: 1.4rem; 
            text-transform: uppercase; 
            letter-spacing: 4px; 
            font-weight: 900;
            background: linear-gradient(135deg, #00ffcc, #00ff88);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            text-shadow: 0 0 30px rgba(0, 255, 204, 0.5);
            animation: glow 2s ease-in-out infinite;
        }
        
        @keyframes glow {
            0%, 100% { filter: brightness(1); }
            50% { filter: brightness(1.3); }
        }
        
        p { 
            font-size: 0.85rem; 
            margin: 8px 0; 
            opacity: 0.95;
            line-height: 1.6;
            transition: all 0.3s ease;
        }
        
        p:hover {
            opacity: 1;
            transform: translateX(3px);
        }
        
        .highlight { 
            color: #fff; 
            font-weight: 700; 
            padding: 2px 8px;
            background: rgba(0, 255, 204, 0.2);
            border-radius: 4px;
            text-shadow: 0 0 10px #00ffcc;
            display: inline-block;
            transition: all 0.3s ease;
        }
        
        .highlight:hover {
            background: rgba(0, 255, 204, 0.3);
            transform: scale(1.05);
        }
        
        #mode-indicator {
            position: absolute;
            bottom: 40px; 
            left: 50%;
            transform: translateX(-50%);
            font-size: 2.5rem;
            font-weight: 900;
            background: linear-gradient(135deg, #00ffcc, #00ff88, #00ffcc);
            background-size: 200% 200%;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            pointer-events: none;
            letter-spacing: 4px;
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            animation: gradientShift 3s ease infinite;
            filter: drop-shadow(0 0 20px rgba(0, 255, 204, 0.6)) 
                    drop-shadow(0 0 40px rgba(0, 255, 204, 0.4));
        }
        
        @keyframes gradientShift {
            0%, 100% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
        }
        
        #gesture-feedback {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scale(0.8);
            font-size: 5rem;
            opacity: 0;
            pointer-events: none;
            transition: all 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
            filter: drop-shadow(0 0 40px rgba(255, 255, 255, 0.8))
                    drop-shadow(0 0 80px rgba(0, 255, 204, 0.6));
        }
        
        #gesture-feedback.show {
            opacity: 1;
            transform: translate(-50%, -50%) scale(1);
        }
        
        .stat-bar {
            margin-top: 6px;
            font-size: 0.75rem;
            color: #00ffcc;
            opacity: 0.8;
            padding: 4px 0;
            border-left: 3px solid rgba(0, 255, 204, 0.4);
            padding-left: 10px;
            transition: all 0.3s ease;
        }
        
        .stat-bar:hover {
            border-left-color: #00ffcc;
            opacity: 1;
            padding-left: 15px;
        }
        
        .section-title {
            color: #ff00cc;
            font-weight: 700;
            margin-top: 15px;
            margin-bottom: 8px;
            font-size: 0.95rem;
            letter-spacing: 2px;
            padding: 6px 0;
            border-bottom: 2px solid rgba(255, 0, 204, 0.3);
            text-shadow: 0 0 10px rgba(255, 0, 204, 0.5);
        }
        
        #feature-panel {
            position: absolute;
            top: 20px;
            right: 20px;
            background: linear-gradient(135deg, rgba(30, 0, 30, 0.9) 0%, rgba(20, 0, 20, 0.85) 100%);
            padding: 20px;
            border-radius: 16px;
            border: 2px solid transparent;
            background-clip: padding-box;
            color: white;
            max-width: 300px;
            backdrop-filter: blur(20px) saturate(180%);
            box-shadow: 
                0 8px 32px rgba(255, 0, 204, 0.2),
                inset 0 1px 0 rgba(255, 255, 255, 0.1),
                0 0 0 2px rgba(255, 0, 204, 0.3);
            z-index: 10;
            pointer-events: none;
            animation: slideInRight 0.6s cubic-bezier(0.4, 0, 0.2, 1);
        }
        
        @keyframes slideInRight {
            from {
                opacity: 0;
                transform: translateX(50px);
            }
            to {
                opacity: 1;
                transform: translateX(0);
            }
        }
        
        #feature-panel h3 {
            margin: 0 0 15px 0;
            color: #ff00cc;
            font-size: 1.1rem;
            font-weight: 900;
            letter-spacing: 2px;
            text-shadow: 0 0 15px rgba(255, 0, 204, 0.6);
        }
        
        .feature-item {
            font-size: 0.8rem;
            margin: 8px 0;
            padding: 6px 10px;
            border-radius: 6px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.05);
            transition: all 0.3s ease;
            background: rgba(255, 255, 255, 0.02);
        }
        
        .feature-item:hover {
            background: rgba(255, 255, 255, 0.05);
            transform: translateX(-3px);
        }
        
        .feature-active {
            color: #00ff88;
            font-weight: 700;
            text-shadow: 0 0 10px rgba(0, 255, 136, 0.6);
            background: rgba(0, 255, 136, 0.1);
            border-left: 3px solid #00ff88;
            padding-left: 12px;
        }
        
        .feature-inactive {
            color: #555;
            opacity: 0.6;
        }
        
        #particle-trail {
            position: absolute;
            top: 0;
            left: 0;
            pointer-events: none;
            z-index: 1;
            mix-blend-mode: screen;
        }
        
        .help-toggle {
            position: absolute;
            bottom: 25px;
            left: 25px;
            background: linear-gradient(135deg, #ff00cc, #cc0099);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 12px;
            cursor: pointer;
            font-family: 'Orbitron', monospace;
            font-weight: 700;
            font-size: 0.9rem;
            letter-spacing: 1px;
            z-index: 20;
            pointer-events: auto;
            box-shadow: 
                0 4px 15px rgba(255, 0, 204, 0.4),
                inset 0 1px 0 rgba(255, 255, 255, 0.2);
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            text-transform: uppercase;
        }
        
        .help-toggle:hover {
            background: linear-gradient(135deg, #ff33dd, #dd00aa);
            transform: translateY(-2px);
            box-shadow: 
                0 6px 20px rgba(255, 0, 204, 0.6),
                inset 0 1px 0 rgba(255, 255, 255, 0.3);
        }
        
        .help-toggle:active {
            transform: translateY(0);
            box-shadow: 
                0 2px 10px rgba(255, 0, 204, 0.4),
                inset 0 1px 0 rgba(255, 255, 255, 0.2);
        }
        
        /* Loading animation */
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        
        /* Smooth transitions */
        .smooth-transition {
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
        }
        
        /* Glass morphism effect */
        .glass {
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
    </style>
</head>
<body>

    <div id="ui">
        <h1>‚ö° NebulaTouch v3 ULTRA</h1>
        <p>Mode: <span id="mode-text" class="highlight">SHAPE VIEW</span></p>
        <p class="stat-bar">Shape: <span id="shape-name" class="highlight">SPHERE</span></p>
        <p class="stat-bar">Scale: <span id="scale-value" class="highlight">1.0x</span></p>
        <p class="stat-bar">Hands: <span id="hand-count" class="highlight">0</span></p>
        <p class="stat-bar">FPS: <span id="fps-counter" class="highlight">60</span></p>
        <hr style="border-color: #333">
        
        <p class="section-title">üñêÔ∏è ONE HAND GESTURES</p>
        <div id="instructions-shape">
            <p>üëã <b>Swipe Fast:</b> Scroll Shapes</p>
            <p>ü§è <b>Pinch Distance:</b> Resize Object</p>
            <p>‚úã <b>Move Slow:</b> Rotate View</p>
            <p>‚úåÔ∏è <b>Peace Sign:</b> Auto-Rotate Toggle</p>
            <p>üëç <b>Thumbs Up:</b> Random Colors</p>
            <p>üëé <b>Thumbs Down:</b> Reset View</p>
            <p>‚òùÔ∏è <b>Point Up:</b> Increase Particle Speed</p>
            <p>ü§ò <b>Rock Sign:</b> Explode Effect</p>
            <p>üññ <b>Vulcan:</b> Freeze/Unfreeze</p>
        </div>
        
        <p class="section-title">üôå TWO HAND GESTURES</p>
        <p>ü§≤ <b>Both Open Palms:</b> Gravity Field</p>
        <p>‚úåÔ∏è‚úåÔ∏è <b>Both Peace:</b> Mirror Mode</p>
        <p>üëè <b>Clap (Close Together):</b> Shockwave</p>
        <p>ü§èü§è <b>Both Pinch:</b> Zoom Camera</p>
        <p>üëê <b>Spread Apart:</b> Particle Expansion</p>
        <p>üîÑ <b>Rotate Hands:</b> Spin Particles</p>
        
        <p class="section-title">‚úèÔ∏è DRAW MODE</p>
        <div id="instructions-draw" style="display:none;">
            <p>ü§è <b>Pinch & Move:</b> Draw in 3D</p>
            <p>‚úã <b>Release:</b> Stop Drawing</p>
            <p>üëã <b>Swipe:</b> Clear Canvas</p>
            <p>‚úåÔ∏è <b>Peace:</b> Change Brush Color</p>
            <p>üëç <b>Thumbs Up:</b> Increase Brush Size</p>
            <p>üëé <b>Thumbs Down:</b> Decrease Brush Size</p>
        </div>
        
        <p style="margin-top:10px; font-size: 0.7rem; color: #aaa;">üí° Pinch the orbs to switch modes</p>
    </div>

    <div id="feature-panel">
        <h3 style="margin: 0 0 10px 0; color: #ff00cc;">üéõÔ∏è Active Features</h3>
        <div class="feature-item"><span id="f-auto-rotate">‚≠ï Auto-Rotate</span></div>
        <div class="feature-item"><span id="f-gravity">‚≠ï Gravity Field</span></div>
        <div class="feature-item"><span id="f-mirror">‚≠ï Mirror Mode</span></div>
        <div class="feature-item"><span id="f-freeze">‚≠ï Freeze</span></div>
        <div class="feature-item"><span id="f-trails">‚≠ï Particle Trails</span></div>
        <div class="feature-item"><span id="f-sound">üîä Sound Effects</span></div>
        <div class="feature-item"><span id="f-glow">‚≠ï Glow Effect</span></div>
        <div class="feature-item"><span id="f-music">üéµ Music Mode</span></div>
        <div class="feature-item"><span id="f-rainbow">‚≠ï Rainbow Mode</span></div>
        <div class="feature-item"><span id="f-pulsate">‚≠ï Pulsate</span></div>
    </div>

    <button class="help-toggle" onclick="toggleUI()">Toggle Help</button>
    
    <div id="mode-indicator">Initializing...</div>
    <div id="gesture-feedback"></div>
    <canvas id="particle-trail"></canvas>
    <video id="video-input" playsinline></video>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <script>
        // --- AUDIO CONTEXT FOR SOUND EFFECTS ---
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        
        function playSound(frequency, duration, type = 'sine') {
            if (!state.soundEnabled) return;
            const oscillator = audioCtx.createOscillator();
            const gainNode = audioCtx.createGain();
            oscillator.connect(gainNode);
            gainNode.connect(audioCtx.destination);
            oscillator.frequency.value = frequency;
            oscillator.type = type;
            gainNode.gain.setValueAtTime(0.1, audioCtx.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + duration);
            oscillator.start(audioCtx.currentTime);
            oscillator.stop(audioCtx.currentTime + duration);
        }

        // --- CONFIGURATION ---
        const CONFIG = {
            particleCount: 10000,
            camZ: 40,
            swipeThreshold: 0.8,
            pinchThreshold: 0.05,
            drawDistance: 30,
            clapThreshold: 0.15,
            handSpreadThreshold: 0.6
        };

        // --- STATE MANAGEMENT ---
        const state = {
            mode: 'SHAPE',
            hand: { x: 0, y: 0, z: 0 },
            hand2: { x: 0, y: 0, z: 0 },
            lastHandX: 0,
            lastHandY: 0,
            velocity: 0,
            pinchDist: 0.1,
            isPinching: false,
            swipeCooldown: 0,
            currentShapeIdx: 0,
            autoRotate: false,
            gravityField: false,
            mirrorMode: false,
            freeze: false,
            particleTrails: false,
            soundEnabled: true,
            glowEffect: false,
            musicMode: false,
            rainbowMode: false,
            pulsate: false,
            gestureCooldown: 0,
            explosionActive: false,
            brushSize: 1,
            handCount: 0,
            particleSpeed: 0.12, // Increased for smoother morphing
            lastFrameTime: Date.now(),
            fps: 60,
            smoothRotation: { x: 0, y: 0 },
            targetRotation: { x: 0, y: 0 }
        };

        // --- 2D CANVAS FOR TRAILS ---
        const trailCanvas = document.getElementById('particle-trail');
        trailCanvas.width = window.innerWidth;
        trailCanvas.height = window.innerHeight;
        const trailCtx = trailCanvas.getContext('2d');

        // --- THREE.JS SETUP ---
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x050505, 0.012);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = CONFIG.camZ;

        const renderer = new THREE.WebGLRenderer({ 
            antialias: true, 
            alpha: true,
            powerPreference: "high-performance",
            precision: "highp"
        });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); // Limit for performance
        document.body.appendChild(renderer.domElement);

        // Lights
        const ambientLight = new THREE.AmbientLight(0x404040, 0.5);
        scene.add(ambientLight);
        const pointLight = new THREE.PointLight(0x00ffcc, 1, 100);
        pointLight.position.set(20, 20, 20);
        scene.add(pointLight);

        const pointLight2 = new THREE.PointLight(0xff00cc, 1, 100);
        pointLight2.position.set(-20, -20, 20);
        scene.add(pointLight2);

        // --- ENHANCED PARTICLE SYSTEM ---
        const geometry = new THREE.BufferGeometry();
        const positions = new Float32Array(CONFIG.particleCount * 3);
        const targetPositions = new Float32Array(CONFIG.particleCount * 3);
        const velocities = new Float32Array(CONFIG.particleCount * 3);
        const colors = new Float32Array(CONFIG.particleCount * 3);
        const sizes = new Float32Array(CONFIG.particleCount);

        for (let i = 0; i < CONFIG.particleCount; i++) {
            const idx = i * 3;
            positions[idx] = (Math.random() - 0.5) * 100;
            positions[idx+1] = (Math.random() - 0.5) * 100;
            positions[idx+2] = (Math.random() - 0.5) * 100;
            targetPositions[idx] = positions[idx];
            targetPositions[idx+1] = positions[idx+1];
            targetPositions[idx+2] = positions[idx+2];
            velocities[idx] = 0;
            velocities[idx+1] = 0;
            velocities[idx+2] = 0;
            colors[idx] = 1;
            colors[idx+1] = 1;
            colors[idx+2] = 1;
            sizes[i] = Math.random() * 0.5 + 0.1;
        }

        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
        geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));

        const material = new THREE.PointsMaterial({
            size: 0.4,
            vertexColors: true,
            blending: THREE.AdditiveBlending,
            transparent: true,
            opacity: 0.95,
            sizeAttenuation: true,
            depthWrite: false,
            depthTest: true
        });

        const particleSystem = new THREE.Points(geometry, material);
        scene.add(particleSystem);

        // --- DRAWING SYSTEM ---
        const drawingGroup = new THREE.Group();
        scene.add(drawingGroup);
        
        let currentLine = null;
        let currentLineGeo = null;
        let currentLinePositions = [];
        let currentBrushColor = new THREE.Color().setHSL(Math.random(), 1, 0.5);

        function startStroke() {
            currentLinePositions = [];
            currentLineGeo = new THREE.BufferGeometry();
            const lineMat = new THREE.LineBasicMaterial({ 
                color: currentBrushColor,
                linewidth: state.brushSize * 3,
                transparent: true,
                opacity: 0.8
            });
            currentLine = new THREE.Line(currentLineGeo, lineMat);
            drawingGroup.add(currentLine);
            playSound(400, 0.05, 'triangle');
        }

        function updateStroke(x, y) {
            if (!currentLine) return;
            currentLinePositions.push(x, y, 0);
            const posAttr = new THREE.Float32BufferAttribute(currentLinePositions, 3);
            currentLineGeo.setAttribute('position', posAttr);
        }

        function endStroke() {
            currentLine = null;
        }

        function clearDrawing() {
            while(drawingGroup.children.length > 0) {
                const child = drawingGroup.children[0];
                child.geometry.dispose();
                child.material.dispose();
                drawingGroup.remove(child);
            }
            showGestureFeedback('üóëÔ∏è');
            playSound(200, 0.2, 'sawtooth');
        }

        // --- UI BUTTONS ---
        const btnShapeGeo = new THREE.SphereGeometry(2.5, 32, 32);
        const btnShapeMat = new THREE.MeshPhongMaterial({ 
            color: 0x00ffff, 
            wireframe: true,
            emissive: 0x00ffff,
            emissiveIntensity: 0.3
        });
        const btnShape = new THREE.Mesh(btnShapeGeo, btnShapeMat);
        btnShape.position.set(-18, -12, 10);
        scene.add(btnShape);

        const btnDrawGeo = new THREE.SphereGeometry(2.5, 32, 32);
        const btnDrawMat = new THREE.MeshPhongMaterial({ 
            color: 0xff00cc, 
            wireframe: true,
            emissive: 0xff00cc,
            emissiveIntensity: 0.3
        });
        const btnDraw = new THREE.Mesh(btnDrawGeo, btnDrawMat);
        btnDraw.position.set(18, -12, 10);
        scene.add(btnDraw);

        // --- EXPANDED SHAPE FORMULAS ---
        const shapeFormulas = {
            'sphere': (i) => {
                const r = 12;
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);
                return [r * Math.sin(phi) * Math.cos(theta), r * Math.sin(phi) * Math.sin(theta), r * Math.cos(phi), 0.1, 0.8, 1.0];
            },
            'heart': (i) => {
                const t = Math.random() * Math.PI * 2;
                const scale = 0.8;
                const x = 16 * Math.pow(Math.sin(t), 3);
                const y = 13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t);
                const z = (Math.random() - 0.5) * 6;
                return [x * scale, y * scale, z, 1.0, 0.2, 0.4];
            },
            'saturn': (i) => {
                let x,y,z,r,g,b;
                if (Math.random() > 0.4) {
                    const theta = Math.random() * Math.PI * 2;
                    const rad = 10 + Math.random() * 8;
                    x = rad * Math.cos(theta);
                    z = rad * Math.sin(theta);
                    y = (Math.random()-0.5);
                    r=0.8; g=0.7; b=0.3;
                } else {
                    const rad = 6;
                    const theta = Math.random() * Math.PI * 2;
                    const phi = Math.acos(2 * Math.random() - 1);
                    x = rad * Math.sin(phi) * Math.cos(theta);
                    y = rad * Math.sin(phi) * Math.sin(theta);
                    z = rad * Math.cos(phi);
                    r=0.9; g=0.5; b=0.1;
                }
                return [x,y,z,r,g,b];
            },
            'flower': (i) => {
                const k = 5;
                const theta = Math.random() * Math.PI * 2;
                const rad = 10 * Math.cos(k * theta) + 5;
                const x = rad * Math.cos(theta);
                const y = rad * Math.sin(theta);
                const z = (Math.random() - 0.5) * 5;
                return [x, y, z, 0.8, 0.1, 0.9];
            },
            'fireworks': (i) => {
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);
                const r = Math.pow(Math.random(), 0.3) * 20;
                const x = r * Math.sin(phi) * Math.cos(theta);
                const y = r * Math.sin(phi) * Math.sin(theta);
                const z = r * Math.cos(phi);
                return [x, y, z, 1.0, 0.5 + Math.random() * 0.5, 0];
            },
            'spiral': (i) => {
                const t = (i / CONFIG.particleCount) * Math.PI * 10;
                const r = t * 1.5;
                const x = Math.cos(t) * r;
                const y = (i / CONFIG.particleCount - 0.5) * 40;
                const z = Math.sin(t) * r;
                return [x, y, z, 0.5, 0.8, 1.0];
            },
            'cube': (i) => {
                const face = Math.floor(Math.random() * 6);
                const u = (Math.random() - 0.5) * 20;
                const v = (Math.random() - 0.5) * 20;
                let x, y, z;
                if (face === 0) { x = 10; y = u; z = v; }
                else if (face === 1) { x = -10; y = u; z = v; }
                else if (face === 2) { x = u; y = 10; z = v; }
                else if (face === 3) { x = u; y = -10; z = v; }
                else if (face === 4) { x = u; y = v; z = 10; }
                else { x = u; y = v; z = -10; }
                return [x, y, z, 0.3, 1.0, 0.8];
            },
            'torus': (i) => {
                const u = Math.random() * Math.PI * 2;
                const v = Math.random() * Math.PI * 2;
                const R = 12, r = 5;
                const x = (R + r * Math.cos(v)) * Math.cos(u);
                const y = (R + r * Math.cos(v)) * Math.sin(u);
                const z = r * Math.sin(v);
                return [x, y, z, 0.9, 0.3, 0.7];
            },
            'helix': (i) => {
                const t = (i / CONFIG.particleCount) * Math.PI * 6;
                const r = 8;
                const x = r * Math.cos(t);
                const z = r * Math.sin(t);
                const y = (i / CONFIG.particleCount - 0.5) * 30;
                return [x, y, z, 0.2, 0.9, 0.5];
            },
            'star': (i) => {
                const angle = Math.random() * Math.PI * 2;
                const spike = Math.floor(Math.random() * 5);
                const baseAngle = (spike / 5) * Math.PI * 2;
                const variation = (Math.random() - 0.5) * (Math.PI / 5);
                const finalAngle = baseAngle + variation;
                const r = (Math.random() * 8 + 8) * (1 + Math.sin(5 * angle));
                const x = r * Math.cos(finalAngle);
                const y = r * Math.sin(finalAngle);
                const z = (Math.random() - 0.5) * 3;
                return [x, y, z, 1.0, 0.9, 0.2];
            },
            'galaxy': (i) => {
                const arm = Math.floor(Math.random() * 3);
                const t = Math.random() * Math.PI * 4;
                const r = t * 2.5;
                const armAngle = (arm / 3) * Math.PI * 2;
                const x = r * Math.cos(t + armAngle);
                const z = r * Math.sin(t + armAngle);
                const y = (Math.random() - 0.5) * 3;
                return [x, y, z, 0.9, 0.8, 1.0];
            },
            'dna': (i) => {
                const t = (i / CONFIG.particleCount) * Math.PI * 8;
                const r = 6;
                const strand = i % 2;
                const x = r * Math.cos(t + strand * Math.PI);
                const z = r * Math.sin(t + strand * Math.PI);
                const y = (i / CONFIG.particleCount - 0.5) * 35;
                return [x, y, z, strand ? 1.0 : 0.2, 0.3, strand ? 0.2 : 1.0];
            }
        };

        const shapeKeys = Object.keys(shapeFormulas);

        function morphToShape(name) {
            const func = shapeFormulas[name];
            for (let i = 0; i < CONFIG.particleCount; i++) {
                const [x, y, z, r, g, b] = func(i);
                const idx = i * 3;
                targetPositions[idx] = x;
                targetPositions[idx+1] = y;
                targetPositions[idx+2] = z;
                if (!state.rainbowMode) {
                    colors[idx] = r; colors[idx+1] = g; colors[idx+2] = b;
                }
            }
            geometry.attributes.color.needsUpdate = true;
            document.getElementById('shape-name').innerText = name.toUpperCase();
            document.getElementById('mode-indicator').innerText = name.toUpperCase();
            playSound(440 + state.currentShapeIdx * 50, 0.1, 'sine');
        }

        function randomizeColors() {
            const hue = Math.random();
            for (let i = 0; i < CONFIG.particleCount; i++) {
                const color = new THREE.Color().setHSL((hue + i / CONFIG.particleCount * 0.3) % 1, 1, 0.5);
                const idx = i * 3;
                colors[idx] = color.r;
                colors[idx+1] = color.g;
                colors[idx+2] = color.b;
            }
            geometry.attributes.color.needsUpdate = true;
            showGestureFeedback('üé®');
            playSound(800, 0.15, 'square');
        }

        function resetView() {
            particleSystem.rotation.set(0, 0, 0);
            particleSystem.scale.set(1, 1, 1);
            camera.position.z = CONFIG.camZ;
            state.particleSpeed = 0.08;
            showGestureFeedback('üîÑ');
            playSound(300, 0.2, 'triangle');
        }

        function explodeParticles() {
            state.explosionActive = true;
            for (let i = 0; i < CONFIG.particleCount; i++) {
                const idx = i * 3;
                velocities[idx] = (Math.random() - 0.5) * 5;
                velocities[idx+1] = (Math.random() - 0.5) * 5;
                velocities[idx+2] = (Math.random() - 0.5) * 5;
            }
            showGestureFeedback('üí•');
            playSound(100, 0.5, 'sawtooth');
            setTimeout(() => { state.explosionActive = false; }, 2000);
        }

        function createShockwave(centerX, centerY) {
            const posArr = geometry.attributes.position.array;
            for (let i = 0; i < CONFIG.particleCount; i++) {
                const idx = i * 3;
                const dx = posArr[idx] - centerX;
                const dy = posArr[idx+1] - centerY;
                const dist = Math.sqrt(dx*dx + dy*dy);
                if (dist < 30) {
                    const force = (30 - dist) / 30;
                    velocities[idx] += (dx / dist) * force * 3;
                    velocities[idx+1] += (dy / dist) * force * 3;
                }
            }
            showGestureFeedback('üí´');
            playSound(150, 0.3, 'sine');
        }

        function showGestureFeedback(emoji) {
            const feedback = document.getElementById('gesture-feedback');
            feedback.textContent = emoji;
            feedback.classList.add('show');
            
            // Add subtle rotation for more dynamic feedback
            feedback.style.transform = 'translate(-50%, -50%) scale(1) rotate(' + (Math.random() * 20 - 10) + 'deg)';
            
            setTimeout(() => {
                feedback.classList.remove('show');
                feedback.style.transform = 'translate(-50%, -50%) scale(0.8) rotate(0deg)';
            }, 600);
        }

        function updateFeatureDisplay(feature, active) {
            const element = document.getElementById('f-' + feature);
            if (element) {
                element.className = active ? 'feature-active' : 'feature-inactive';
            }
        }

        morphToShape('sphere');

        // --- GESTURE DETECTION ---
        function detectGesture(landmarks) {
            const thumb_tip = landmarks[4];
            const index_tip = landmarks[8];
            const middle_tip = landmarks[12];
            const ring_tip = landmarks[16];
            const pinky_tip = landmarks[20];
            const index_mcp = landmarks[5];
            const middle_mcp = landmarks[9];
            const ring_mcp = landmarks[13];
            const pinky_mcp = landmarks[17];

            function isExtended(tip, mcp) {
                return tip.y < mcp.y;
            }

            const indexExt = isExtended(index_tip, index_mcp);
            const middleExt = isExtended(middle_tip, middle_mcp);
            const ringExt = isExtended(ring_tip, ring_mcp);
            const pinkyExt = isExtended(pinky_tip, pinky_mcp);
            const thumbExt = thumb_tip.x < landmarks[3].x;

            // Open palm
            if (indexExt && middleExt && ringExt && pinkyExt) {
                return 'open_palm';
            }

            // Peace sign
            if (indexExt && middleExt && !ringExt && !pinkyExt) {
                return 'peace';
            }

            // Thumbs up
            if (!indexExt && !middleExt && !ringExt && !pinkyExt && thumb_tip.y < landmarks[3].y) {
                return 'thumbs_up';
            }

            // Thumbs down
            if (!indexExt && !middleExt && !ringExt && !pinkyExt && thumb_tip.y > landmarks[3].y) {
                return 'thumbs_down';
            }

            // Point up
            if (indexExt && !middleExt && !ringExt && !pinkyExt && index_tip.y < middle_mcp.y - 0.1) {
                return 'point_up';
            }

            // Rock sign
            if (indexExt && !middleExt && !ringExt && pinkyExt) {
                return 'rock';
            }

            // Vulcan (spread between middle and ring)
            if (indexExt && middleExt && ringExt && pinkyExt) {
                const middleRingDist = Math.abs(middle_tip.x - ring_tip.x);
                const indexMiddleDist = Math.abs(index_tip.x - middle_tip.x);
                if (middleRingDist > indexMiddleDist * 1.5) {
                    return 'vulcan';
                }
            }

            return null;
        }

        function detectTwoHandGesture(hands1, hands2) {
            const index1 = hands1[8];
            const index2 = hands2[8];
            const thumb1 = hands1[4];
            const thumb2 = hands2[4];
            
            const handDist = Math.sqrt(
                Math.pow(index1.x - index2.x, 2) + 
                Math.pow(index1.y - index2.y, 2)
            );

            const gesture1 = detectGesture(hands1);
            const gesture2 = detectGesture(hands2);

            // Clap (hands close together)
            if (handDist < CONFIG.clapThreshold) {
                return 'clap';
            }

            // Spread apart
            if (handDist > CONFIG.handSpreadThreshold) {
                return 'spread';
            }

            // Both peace signs
            if (gesture1 === 'peace' && gesture2 === 'peace') {
                return 'both_peace';
            }

            // Both open palms
            if (gesture1 === 'open_palm' && gesture2 === 'open_palm') {
                return 'both_open';
            }

            // Both pinching
            const pinch1 = Math.sqrt(Math.pow(index1.x - thumb1.x, 2) + Math.pow(index1.y - thumb1.y, 2));
            const pinch2 = Math.sqrt(Math.pow(index2.x - thumb2.x, 2) + Math.pow(index2.y - thumb2.y, 2));
            
            if (pinch1 < CONFIG.pinchThreshold && pinch2 < CONFIG.pinchThreshold) {
                return 'both_pinch';
            }

            return null;
        }

        // --- MEDIAPIPE HANDLER ---
        function onResults(results) {
            const shapeName = shapeKeys[state.currentShapeIdx].toUpperCase();
            document.getElementById('mode-indicator').innerText = state.mode === 'SHAPE' ? shapeName : "DRAW MODE";
            document.getElementById('scale-value').innerText = particleSystem.scale.x.toFixed(1) + 'x';
            
            const handCount = results.multiHandLandmarks ? results.multiHandLandmarks.length : 0;
            state.handCount = handCount;
            document.getElementById('hand-count').innerText = handCount;

            if (handCount > 0) {
                const landmarks = results.multiHandLandmarks[0];
                const idxFinger = landmarks[8];
                const thumb = landmarks[4];
                
                const x = (idxFinger.x - 0.5) * -40;
                const y = (idxFinger.y - 0.5) * -30;
                
                state.velocity = x - state.lastHandX;
                state.lastHandX = x;
                state.lastHandY = y;

                state.hand.x = x;
                state.hand.y = y;

                const dist = Math.sqrt(
                    Math.pow(idxFinger.x - thumb.x, 2) + 
                    Math.pow(idxFinger.y - thumb.y, 2)
                );
                state.pinchDist = dist;
                const wasPinching = state.isPinching;
                state.isPinching = dist < CONFIG.pinchThreshold;

                // Two hand gestures
                if (handCount === 2) {
                    const landmarks2 = results.multiHandLandmarks[1];
                    const idxFinger2 = landmarks2[8];
                    const x2 = (idxFinger2.x - 0.5) * -40;
                    const y2 = (idxFinger2.y - 0.5) * -30;
                    state.hand2.x = x2;
                    state.hand2.y = y2;

                    const twoHandGesture = detectTwoHandGesture(landmarks, landmarks2);
                    
                    if (state.gestureCooldown <= 0 && twoHandGesture) {
                        if (twoHandGesture === 'both_open') {
                            state.gravityField = !state.gravityField;
                            updateFeatureDisplay('gravity', state.gravityField);
                            showGestureFeedback(state.gravityField ? 'üåå' : '‚≠ï');
                            playSound(600, 0.2, 'sine');
                            state.gestureCooldown = 30;
                        } else if (twoHandGesture === 'both_peace') {
                            state.mirrorMode = !state.mirrorMode;
                            updateFeatureDisplay('mirror', state.mirrorMode);
                            showGestureFeedback(state.mirrorMode ? 'ü™û' : '‚≠ï');
                            playSound(700, 0.2, 'triangle');
                            state.gestureCooldown = 30;
                        } else if (twoHandGesture === 'clap') {
                            createShockwave(0, 0);
                            state.gestureCooldown = 30;
                        } else if (twoHandGesture === 'both_pinch') {
                            const zoomDist = Math.sqrt(
                                Math.pow(idxFinger.x - idxFinger2.x, 2) + 
                                Math.pow(idxFinger.y - idxFinger2.y, 2)
                            );
                            const targetZ = 20 + (1 - Math.min(zoomDist, 1)) * 60;
                            camera.position.z += (targetZ - camera.position.z) * 0.1; // Smooth zoom
                        } else if (twoHandGesture === 'spread') {
                            const spreadFactor = Math.sqrt(
                                Math.pow(x - x2, 2) + Math.pow(y - y2, 2)
                            ) / 20;
                            for (let i = 0; i < CONFIG.particleCount; i++) {
                                const idx = i * 3;
                                targetPositions[idx] *= (1 + spreadFactor * 0.05);
                                targetPositions[idx+1] *= (1 + spreadFactor * 0.05);
                                targetPositions[idx+2] *= (1 + spreadFactor * 0.05);
                            }
                        }
                    }
                }

                // Single hand gestures
                const gesture = detectGesture(landmarks);
                
                if (state.gestureCooldown <= 0 && gesture) {
                    if (gesture === 'peace' && state.mode === 'SHAPE') {
                        state.autoRotate = !state.autoRotate;
                        updateFeatureDisplay('auto-rotate', state.autoRotate);
                        showGestureFeedback(state.autoRotate ? 'üîÑ' : '‚è∏Ô∏è');
                        playSound(500, 0.15, 'sine');
                        state.gestureCooldown = 30;
                    } else if (gesture === 'peace' && state.mode === 'DRAW') {
                        currentBrushColor = new THREE.Color().setHSL(Math.random(), 1, 0.5);
                        showGestureFeedback('üé®');
                        playSound(600, 0.1, 'triangle');
                        state.gestureCooldown = 20;
                    } else if (gesture === 'thumbs_up' && state.mode === 'SHAPE') {
                        randomizeColors();
                        state.gestureCooldown = 30;
                    } else if (gesture === 'thumbs_up' && state.mode === 'DRAW') {
                        state.brushSize = Math.min(state.brushSize + 0.5, 5);
                        showGestureFeedback('‚ûï');
                        playSound(700, 0.1, 'sine');
                        state.gestureCooldown = 20;
                    } else if (gesture === 'thumbs_down' && state.mode === 'SHAPE') {
                        resetView();
                        state.gestureCooldown = 30;
                    } else if (gesture === 'thumbs_down' && state.mode === 'DRAW') {
                        state.brushSize = Math.max(state.brushSize - 0.5, 0.5);
                        showGestureFeedback('‚ûñ');
                        playSound(500, 0.1, 'sine');
                        state.gestureCooldown = 20;
                    } else if (gesture === 'point_up') {
                        state.particleSpeed = Math.min(state.particleSpeed + 0.02, 0.3);
                        showGestureFeedback('‚ö°');
                        playSound(900, 0.1, 'square');
                        state.gestureCooldown = 20;
                    } else if (gesture === 'rock') {
                        explodeParticles();
                        state.gestureCooldown = 60;
                    } else if (gesture === 'vulcan') {
                        state.freeze = !state.freeze;
                        updateFeatureDisplay('freeze', state.freeze);
                        showGestureFeedback(state.freeze ? '‚ùÑÔ∏è' : 'üî•');
                        playSound(400, 0.2, 'triangle');
                        state.gestureCooldown = 30;
                    }
                } else if (state.gestureCooldown > 0) {
                    state.gestureCooldown--;
                }

                // Button Clicking
                if (state.isPinching && !wasPinching) {
                    if (Math.abs(x - btnShape.position.x) < 6 && Math.abs(y - btnShape.position.y) < 6) {
                        state.mode = 'SHAPE';
                        document.getElementById('mode-text').innerText = "SHAPE VIEW";
                        document.getElementById('instructions-shape').style.display = 'block';
                        document.getElementById('instructions-draw').style.display = 'none';
                        particleSystem.visible = true;
                        drawingGroup.visible = false;
                        btnShape.material.emissiveIntensity = 1;
                        setTimeout(() => btnShape.material.emissiveIntensity = 0.3, 300);
                        showGestureFeedback('üìê');
                        playSound(800, 0.1, 'sine');
                    }
                    else if (Math.abs(x - btnDraw.position.x) < 6 && Math.abs(y - btnDraw.position.y) < 6) {
                        state.mode = 'DRAW';
                        document.getElementById('mode-text').innerText = "DRAWING";
                        document.getElementById('instructions-shape').style.display = 'none';
                        document.getElementById('instructions-draw').style.display = 'block';
                        particleSystem.visible = false;
                        drawingGroup.visible = true;
                        btnDraw.material.emissiveIntensity = 1;
                        setTimeout(() => btnDraw.material.emissiveIntensity = 0.3, 300);
                        showGestureFeedback('‚úèÔ∏è');
                        playSound(600, 0.1, 'triangle');
                    }
                }

                // Shape Mode Logic
                if (state.mode === 'SHAPE' && !state.freeze) {
                    if (state.swipeCooldown <= 0) {
                        if (state.velocity > CONFIG.swipeThreshold) {
                            state.currentShapeIdx = (state.currentShapeIdx + 1) % shapeKeys.length;
                            morphToShape(shapeKeys[state.currentShapeIdx]);
                            state.swipeCooldown = 20;
                            showGestureFeedback('‚û°Ô∏è');
                        } else if (state.velocity < -CONFIG.swipeThreshold) {
                            state.currentShapeIdx = (state.currentShapeIdx - 1 + shapeKeys.length) % shapeKeys.length;
                            morphToShape(shapeKeys[state.currentShapeIdx]);
                            state.swipeCooldown = 20;
                            showGestureFeedback('‚¨ÖÔ∏è');
                        }
                    } else {
                        state.swipeCooldown--;
                    }
                }

                // Draw Mode Logic
                if (state.mode === 'DRAW') {
                    if (state.isPinching) {
                        if (!currentLine) startStroke();
                        updateStroke(x, y);
                    } else {
                        if (currentLine) endStroke();
                    }

                    if (state.swipeCooldown <= 0 && Math.abs(state.velocity) > CONFIG.swipeThreshold * 1.2) {
                        clearDrawing();
                        state.swipeCooldown = 40;
                    } else if (state.swipeCooldown > 0) {
                        state.swipeCooldown--;
                    }
                }

                // Particle trails with gradient effect
                if (state.particleTrails) {
                    trailCtx.fillStyle = 'rgba(5, 5, 5, 0.1)';
                    trailCtx.fillRect(0, 0, trailCanvas.width, trailCanvas.height);
                    
                    // Create gradient for trail
                    const gradient = trailCtx.createRadialGradient(
                        (idxFinger.x) * trailCanvas.width,
                        (idxFinger.y) * trailCanvas.height,
                        0,
                        (idxFinger.x) * trailCanvas.width,
                        (idxFinger.y) * trailCanvas.height,
                        20
                    );
                    gradient.addColorStop(0, 'rgba(0, 255, 204, 0.8)');
                    gradient.addColorStop(0.5, 'rgba(0, 255, 204, 0.4)');
                    gradient.addColorStop(1, 'rgba(0, 255, 204, 0)');
                    
                    trailCtx.fillStyle = gradient;
                    trailCtx.beginPath();
                    trailCtx.arc(
                        (idxFinger.x) * trailCanvas.width,
                        (idxFinger.y) * trailCanvas.height,
                        10,
                        0,
                        Math.PI * 2
                    );
                    trailCtx.fill();
                }
            }
        }

        // --- ANIMATION LOOP ---
        let frameCount = 0;
        function animate() {
            requestAnimationFrame(animate);

            // FPS Counter
            const now = Date.now();
            const delta = now - state.lastFrameTime;
            if (delta > 0) {
                state.fps = Math.round(1000 / delta);
                document.getElementById('fps-counter').innerText = state.fps;
            }
            state.lastFrameTime = now;

            if (!state.freeze) {
                const positionsArr = geometry.attributes.position.array;
                for (let i = 0; i < CONFIG.particleCount; i++) {
                    const idx = i * 3;

                    // Apply velocities
                    if (state.explosionActive) {
                        positionsArr[idx] += velocities[idx];
                        positionsArr[idx+1] += velocities[idx+1];
                        positionsArr[idx+2] += velocities[idx+2];
                        velocities[idx] *= 0.95;
                        velocities[idx+1] *= 0.95;
                        velocities[idx+2] *= 0.95;
                    }

                    // Gravity field
                    if (state.gravityField && state.handCount > 0) {
                        const dx = state.hand.x - positionsArr[idx];
                        const dy = state.hand.y - positionsArr[idx+1];
                        const dist = Math.sqrt(dx*dx + dy*dy) + 0.1;
                        const force = 0.5 / (dist * dist);
                        velocities[idx] += dx * force;
                        velocities[idx+1] += dy * force;
                        positionsArr[idx] += velocities[idx];
                        positionsArr[idx+1] += velocities[idx+1];
                        velocities[idx] *= 0.95;
                        velocities[idx+1] *= 0.95;
                    } else {
                        // Normal morphing with easing
                        const easing = 1 - Math.pow(1 - state.particleSpeed, 2); // Quadratic ease-out
                        positionsArr[idx] += (targetPositions[idx] - positionsArr[idx]) * easing;
                        positionsArr[idx+1] += (targetPositions[idx+1] - positionsArr[idx+1]) * easing;
                        positionsArr[idx+2] += (targetPositions[idx+2] - positionsArr[idx+2]) * easing;
                        
                        // Add subtle ambient motion for organic feel
                        if (!state.explosionActive) {
                            const ambient = Math.sin(frameCount * 0.01 + i * 0.1) * 0.02;
                            positionsArr[idx+1] += ambient;
                        }
                    }

                    // Mirror mode
                    if (state.mirrorMode) {
                        positionsArr[idx] = -positionsArr[idx];
                    }

                    // Rainbow mode with smoother transitions
                    if (state.rainbowMode) {
                        const hue = (frameCount * 0.0015 + i / CONFIG.particleCount) % 1;
                        const saturation = 0.9 + Math.sin(frameCount * 0.01 + i * 0.05) * 0.1;
                        const lightness = 0.5 + Math.sin(frameCount * 0.02 + i * 0.03) * 0.1;
                        const color = new THREE.Color().setHSL(hue, saturation, lightness);
                        colors[idx] = color.r;
                        colors[idx+1] = color.g;
                        colors[idx+2] = color.b;
                    }
                }
                geometry.attributes.position.needsUpdate = true;
                if (state.rainbowMode) {
                    geometry.attributes.color.needsUpdate = true;
                }

                if (state.mode === 'SHAPE') {
                    if (state.autoRotate) {
                        particleSystem.rotation.y += 0.005;
                        particleSystem.rotation.x += 0.002;
                    } else if (Math.abs(state.velocity) < 0.3) {
                        // Smooth rotation with interpolation
                        state.targetRotation.y = state.hand.x * 0.002;
                        state.targetRotation.x = -state.hand.y * 0.002;
                        
                        state.smoothRotation.y += (state.targetRotation.y - state.smoothRotation.y) * 0.1;
                        state.smoothRotation.x += (state.targetRotation.x - state.smoothRotation.x) * 0.1;
                        
                        particleSystem.rotation.y += state.smoothRotation.y;
                        particleSystem.rotation.x += state.smoothRotation.x;
                    }

                    // Pulsate
                    if (state.pulsate) {
                        const pulse = 1 + Math.sin(frameCount * 0.05) * 0.2;
                        particleSystem.scale.setScalar(pulse);
                    } else {
                        const targetScale = Math.max(0.5, Math.min(3.0, state.pinchDist * 10)); 
                        const currentScale = particleSystem.scale.x;
                        const smoothScale = currentScale + (targetScale - currentScale) * 0.15; // Smoother scaling
                        particleSystem.scale.setScalar(smoothScale);
                    }
                }
            }

            const time = Date.now() * 0.001;
            btnShape.rotation.y = time;
            btnDraw.rotation.y = -time;
            btnShape.rotation.z = Math.sin(time * 0.5) * 0.2;
            btnDraw.rotation.z = -Math.sin(time * 0.5) * 0.2;
            btnShape.position.y = -12 + Math.sin(time * 1.5) * 0.8;
            btnDraw.position.y = -12 + Math.sin(time * 1.5 + Math.PI) * 0.8;

            // Enhanced pulsing effect for buttons
            const pulseIntensity = 0.3 + Math.sin(time * 2) * 0.15;
            btnShape.material.emissiveIntensity = pulseIntensity;
            btnDraw.material.emissiveIntensity = pulseIntensity;
            
            // Dynamic light movement
            pointLight.position.x = 20 * Math.cos(time * 0.5);
            pointLight.position.z = 20 * Math.sin(time * 0.5);
            pointLight2.position.x = -20 * Math.cos(time * 0.3);
            pointLight2.position.z = -20 * Math.sin(time * 0.3);

            // Glow effect with dynamic fog
            if (state.glowEffect) {
                scene.fog.density = 0.012 + Math.sin(time * 2) * 0.006;
            }

            renderer.render(scene, camera);
            frameCount++;
        }

        // --- KEYBOARD SHORTCUTS ---
        window.addEventListener('keydown', (e) => {
            switch(e.key.toLowerCase()) {
                case 't':
                    state.particleTrails = !state.particleTrails;
                    updateFeatureDisplay('trails', state.particleTrails);
                    if (!state.particleTrails) {
                        trailCtx.clearRect(0, 0, trailCanvas.width, trailCanvas.height);
                    }
                    break;
                case 's':
                    state.soundEnabled = !state.soundEnabled;
                    updateFeatureDisplay('sound', state.soundEnabled);
                    break;
                case 'g':
                    state.glowEffect = !state.glowEffect;
                    updateFeatureDisplay('glow', state.glowEffect);
                    break;
                case 'm':
                    state.musicMode = !state.musicMode;
                    updateFeatureDisplay('music', state.musicMode);
                    break;
                case 'r':
                    state.rainbowMode = !state.rainbowMode;
                    updateFeatureDisplay('rainbow', state.rainbowMode);
                    break;
                case 'p':
                    state.pulsate = !state.pulsate;
                    updateFeatureDisplay('pulsate', state.pulsate);
                    break;
            }
        });

        // --- UI TOGGLE ---
        function toggleUI() {
            const ui = document.getElementById('ui');
            ui.style.display = ui.style.display === 'none' ? 'block' : 'none';
        }

        // --- INITIALIZATION ---
        const videoElement = document.getElementById('video-input');
        const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
        hands.setOptions({ 
            maxNumHands: 2, 
            modelComplexity: 1, 
            minDetectionConfidence: 0.5, 
            minTrackingConfidence: 0.5 
        });
        hands.onResults(onResults);
        
        const cameraUtils = new Camera(videoElement, {
            onFrame: async () => { await hands.send({image: videoElement}); },
            width: 640, height: 480
        });
        cameraUtils.start();
        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            trailCanvas.width = window.innerWidth;
            trailCanvas.height = window.innerHeight;
        });

    </script>
</body>
</html>
